{
  "client/shared.js": {
    "id": "client/shared.js",
    "type": "js",
    "mtime": 1419240297000,
    "src": "'use strict';\n\n// internal browser events bus.\nvar bus = require(\"../node_modules/backbone-events-standalone\").mixin({});\n\nconsole.log('bus is', bus);\nvar page = require('../public/libs/page.js');\nvar nextBus = require('../components/next-bus/next-bus.js');\nvar nextTrain = require('../components/next-train/next-train.js');\nvar trainStatus = require('../components/train-status/train-status.js');\n\nvar url;\nif(window.location.hostname === 'woodford.today') {\n    url = 'http://woodford.today:80/';\n} else {\n    url = 'http://localhost/';\n}\n\nvar socket = io(url);\n\nnextTrain.bind($('#nextTrain'), socket, bus);\n\n// socket.on('trainStatus', trainStatus.render);\n// socket.on('nextBus', nextBus.render);\n\npage();\n\npage('/central/:stationName', function(context) {\n    if(context.init) {\n        // first page load.\n        //nextTrain.setup(context.params.stationName, socket, bus);\n    } else {\n        // go get the data first.\n        nextTrain.fetch(context.params.stationName, socket, bus);\n    }\n});\n\n\nwindow.onresize = nextTrain.resize;\n",
    "deps": {
      "../node_modules/backbone-events-standalone": "node_modules/backbone-events-standalone/index.js",
      "../public/libs/page.js": "public/libs/page.js",
      "../components/next-bus/next-bus.js": "components/next-bus/next-bus.js",
      "../components/next-train/next-train.js": "components/next-train/next-train.js",
      "../components/train-status/train-status.js": "components/train-status/train-status.js"
    },
    "entry": true
  },
  "public/libs/page.js": {
    "id": "public/libs/page.js",
    "type": "js",
    "mtime": 1413809024000,
    "src": "!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.page=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\n  /* jshint browser:true */\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = _dereq_('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page();\n   *\n   * @param {String|Function} path\n   * @param {Function} fn...\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' == typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' == typeof fn) {\n      var route = new Route(path);\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n    // show <path> with [state]\n    } else if ('string' == typeof path) {\n      page.show(path, fn);\n    // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {String} path\n   * @api public\n   */\n\n  page.base = function(path){\n    if (0 == arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options){\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) window.addEventListener('click', onclick, false);\n    if (!dispatch) return;\n    var url = location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function(){\n    running = false;\n    removeEventListener('click', onclick, false);\n    removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @param {Boolean} dispatch\n   * @return {Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch){\n    var ctx = new Context(path, state);\n    if (false !== dispatch) page.dispatch(ctx);\n    if (!ctx.unhandled) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @return {Context}\n   * @api public\n   */\n\n  page.replace = function(path, state, init, dispatch){\n    var ctx = new Context(path, state);\n    ctx.init = init;\n    if (null == dispatch) dispatch = true;\n    if (dispatch) page.dispatch(ctx);\n    ctx.save();\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Object} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx){\n    var i = 0;\n\n    function next() {\n      var fn = page.callbacks[i++];\n      if (!fn) return unhandled(ctx);\n      fn(ctx, next);\n    }\n\n    next();\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  function unhandled(ctx) {\n    var current = window.location.pathname + window.location.search;\n    if (current == ctx.canonicalPath) return;\n    page.stop();\n    ctx.unhandled = true;\n    window.location = ctx.canonicalPath;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' == path[0] && 0 != path.indexOf(base)) path = base + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? path.slice(i + 1) : '';\n    this.pathname = ~i ? path.slice(0, i) : path;\n    this.params = [];\n\n    // fragment\n    this.hash = '';\n    if (!~this.path.indexOf('#')) return;\n    var parts = this.path.split('#');\n    this.path = parts[0];\n    this.hash = parts[1] || '';\n    this.querystring = this.querystring.split('#')[0];\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function(){\n    history.pushState(this.state, this.title, this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function(){\n    history.replaceState(this.state, this.title, this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {Object} options.\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path\n      , this.keys = []\n      , options.sensitive\n      , options.strict);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn){\n    var self = this;\n    return function(ctx, next){\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {Array} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params){\n    var keys = this.keys\n      , qsIndex = path.indexOf('?')\n      , pathname = ~qsIndex ? path.slice(0, qsIndex) : path\n      , m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n\n      var val = 'string' == typeof m[i]\n        ? decodeURIComponent(m[i])\n        : m[i];\n\n      if (key) {\n        params[key.name] = undefined !== params[key.name]\n          ? params[key.name]\n          : val;\n      } else {\n        params.push(val);\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  function onpopstate(e) {\n    if (e.state) {\n      var path = e.state.path;\n      page.replace(path, e.state);\n    }\n  }\n\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n    if (1 != which(e)) return;\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n    // ensure link\n    var el = e.target;\n    while (el && 'A' != el.nodeName) el = el.parentNode;\n    if (!el || 'A' != el.nodeName) return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (el.pathname == location.pathname && (el.hash || '#' == link)) return;\n\n    // Check for mailto: in the href\n    if (link.indexOf(\"mailto:\") > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // same page\n    var orig = path + el.hash;\n\n    path = path.replace(base, '');\n    if (base && orig == path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null == e.which\n      ? e.button\n      : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return 0 == href.indexOf(origin);\n  }\n\n},{\"path-to-regexp\":2}],2:[function(_dereq_,module,exports){\n/**\n * Expose `pathtoRegexp`.\n */\nmodule.exports = pathtoRegexp;\n\nvar PATH_REGEXP = new RegExp([\n  // Match already escaped characters that would otherwise incorrectly appear\n  // in future matches. This allows the user to escape special characters that\n  // shouldn't be transformed.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n  // \"/route(\\\\d+)\" => [undefined, undefined, undefined, \"\\d+\", undefined]\n  '([\\\\/.])?(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^)])*)\\\\))?|\\\\(((?:\\\\\\\\.|[^)])*)\\\\))([+*?])?',\n  // Match regexp special characters that should always be escaped.\n  '([.+*?=^!:${}()[\\\\]|\\\\/])'\n].join('|'), 'g');\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array should be passed in, which will contain the placeholder key\n * names. For example `/user/:id` will then contain `[\"id\"]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 keys\n * @param  {Object}                options\n * @return {RegExp}\n */\nfunction pathtoRegexp (path, keys, options) {\n  keys = keys || [];\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var index = 0;\n\n  if (path instanceof RegExp) {\n    // Match all capturing groups of a regexp.\n    var groups = path.source.match(/\\((?!\\?)/g) || [];\n\n    // Map all the matches to their numeric keys and push into the keys.\n    keys.push.apply(keys, groups.map(function (match, index) {\n      return {\n        name:      index,\n        delimiter: null,\n        optional:  false,\n        repeat:    false\n      };\n    }));\n\n    // Return the source back to the user.\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n\n    // Generate a new regexp instance by joining all the parts together.\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n\n  // Alter the path string into a usable regexp.\n  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {\n    // Avoiding re-escaping escaped characters.\n    if (escaped) {\n      return escaped;\n    }\n\n    // Escape regexp special characters.\n    if (escape) {\n      return '\\\\' + escape;\n    }\n\n    var repeat   = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n\n    keys.push({\n      name:      key || index++,\n      delimiter: prefix || '/',\n      optional:  optional,\n      repeat:    repeat\n    });\n\n    // Escape the prefix character.\n    prefix = prefix ? '\\\\' + prefix : '';\n\n    // Match using the custom capturing group, or fallback to capturing\n    // everything up to the next slash (or next period if the param was\n    // prefixed with a period).\n    capture = escapeGroup(capture || group || '[^' + (prefix || '\\\\/') + ']+?');\n\n    // Allow parameters to be repeated more than once.\n    if (repeat) {\n      capture = capture + '(?:' + prefix + capture + ')*';\n    }\n\n    // Allow a parameter to be optional.\n    if (optional) {\n      return '(?:' + prefix + '(' + capture + '))?';\n    }\n\n    // Basic parameter support.\n    return prefix + '(' + capture + ')';\n  });\n\n  // Check whether the path ends in a slash as it alters some match behaviour.\n  var endsWithSlash = path[path.length - 1] === '/';\n\n  // In non-strict mode we allow an optional trailing slash in the match. If\n  // the path to match already ended with a slash, we need to remove it for\n  // consistency. The slash is only valid at the very end of a path match, not\n  // anywhere in the middle. This is important for non-ending mode, otherwise\n  // \"/test/\" will match \"/test//route\".\n  if (!strict) {\n    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\\\/(?=$))?';\n  }\n\n  // In non-ending mode, we need prompt the capturing groups to match as much\n  // as possible by using a positive lookahead for the end or next path segment.\n  if (!end) {\n    path += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return new RegExp('^' + path + (end ? '$' : ''), flags);\n};\n\n},{}]},{},[1])\n(1)\n});\n",
    "deps": {}
  },
  "components/next-bus/next-bus.js": {
    "id": "components/next-bus/next-bus.js",
    "type": "js",
    "mtime": 1413624155000,
    "src": "var template = require('./next-bus.jade');\n\nexports.render = function(data) {\n    $('#nextBus').replaceWith(template({ 'nextBus': data }));\n};\n",
    "deps": {
      "./next-bus.jade": "components/next-bus/next-bus.jade"
    }
  },
  "components/next-bus/next-bus.jade": {
    "id": "components/next-bus/next-bus.jade",
    "type": "js",
    "mtime": 1413717949000,
    "src": "var jade = require('jade-runtime');\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n;var locals_for_with = (locals || {});(function (nextBus) {\nbuf.push(\"<div id=\\\"nextBus\\\"><h2>Buses</h2><div class=\\\"direction\\\"><h3>To Barkingside</h3><ul class=\\\"trains\\\">\");\nif ( nextBus['1'])\n{\n// iterate nextBus['1'].buses\n;(function(){\n  var $$obj = nextBus['1'].buses;\n  if ('number' == typeof $$obj.length) {\n\n    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n      var bus = $$obj[$index];\n\nbuf.push(\"<li><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = bus.due) ? \"\" : jade_interp)) + \"</span></div></li>\");\n    }\n\n  } else {\n    var $$l = 0;\n    for (var $index in $$obj) {\n      $$l++;      var bus = $$obj[$index];\n\nbuf.push(\"<li><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = bus.due) ? \"\" : jade_interp)) + \"</span></div></li>\");\n    }\n\n  }\n}).call(this);\n\n}\nbuf.push(\"</ul></div><div class=\\\"direction\\\"><h3>To Walthamstow</h3><ul class=\\\"trains\\\">\");\nif ( nextBus['2'])\n{\n// iterate nextBus['2'].buses\n;(function(){\n  var $$obj = nextBus['2'].buses;\n  if ('number' == typeof $$obj.length) {\n\n    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n      var bus = $$obj[$index];\n\nbuf.push(\"<li><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = bus.due) ? \"\" : jade_interp)) + \"</span></div></li>\");\n    }\n\n  } else {\n    var $$l = 0;\n    for (var $index in $$obj) {\n      $$l++;      var bus = $$obj[$index];\n\nbuf.push(\"<li><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = bus.due) ? \"\" : jade_interp)) + \"</span></div></li>\");\n    }\n\n  }\n}).call(this);\n\n}\nbuf.push(\"</ul></div></div>\");}.call(this,\"nextBus\" in locals_for_with?locals_for_with.nextBus:typeof nextBus!==\"undefined\"?nextBus:undefined));;return buf.join(\"\");\n};",
    "deps": {
      "jade-runtime": "jade-runtime"
    }
  },
  "jade-runtime": {
    "id": "jade-runtime",
    "src": "!function(e){if(\"object\"==typeof exports)module.exports=e();else if(\"function\"==typeof define&&define.amd)define(e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.jade=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\r\n\r\n/**\r\n * Merge two attribute objects giving precedence\r\n * to values in object `b`. Classes are special-cased\r\n * allowing for arrays and merging/joining appropriately\r\n * resulting in a string.\r\n *\r\n * @param {Object} a\r\n * @param {Object} b\r\n * @return {Object} a\r\n * @api private\r\n */\r\n\r\nexports.merge = function merge(a, b) {\r\n  if (arguments.length === 1) {\r\n    var attrs = a[0];\r\n    for (var i = 1; i < a.length; i++) {\r\n      attrs = merge(attrs, a[i]);\r\n    }\r\n    return attrs;\r\n  }\r\n  var ac = a['class'];\r\n  var bc = b['class'];\r\n\r\n  if (ac || bc) {\r\n    ac = ac || [];\r\n    bc = bc || [];\r\n    if (!Array.isArray(ac)) ac = [ac];\r\n    if (!Array.isArray(bc)) bc = [bc];\r\n    a['class'] = ac.concat(bc).filter(nulls);\r\n  }\r\n\r\n  for (var key in b) {\r\n    if (key != 'class') {\r\n      a[key] = b[key];\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Filter null `val`s.\r\n *\r\n * @param {*} val\r\n * @return {Boolean}\r\n * @api private\r\n */\r\n\r\nfunction nulls(val) {\r\n  return val != null && val !== '';\r\n}\r\n\r\n/**\r\n * join array as classes.\r\n *\r\n * @param {*} val\r\n * @return {String}\r\n */\r\nexports.joinClasses = joinClasses;\r\nfunction joinClasses(val) {\r\n  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;\r\n}\r\n\r\n/**\r\n * Render the given classes.\r\n *\r\n * @param {Array} classes\r\n * @param {Array.<Boolean>} escaped\r\n * @return {String}\r\n */\r\nexports.cls = function cls(classes, escaped) {\r\n  var buf = [];\r\n  for (var i = 0; i < classes.length; i++) {\r\n    if (escaped && escaped[i]) {\r\n      buf.push(exports.escape(joinClasses([classes[i]])));\r\n    } else {\r\n      buf.push(joinClasses(classes[i]));\r\n    }\r\n  }\r\n  var text = joinClasses(buf);\r\n  if (text.length) {\r\n    return ' class=\"' + text + '\"';\r\n  } else {\r\n    return '';\r\n  }\r\n};\r\n\r\n/**\r\n * Render the given attribute.\r\n *\r\n * @param {String} key\r\n * @param {String} val\r\n * @param {Boolean} escaped\r\n * @param {Boolean} terse\r\n * @return {String}\r\n */\r\nexports.attr = function attr(key, val, escaped, terse) {\r\n  if ('boolean' == typeof val || null == val) {\r\n    if (val) {\r\n      return ' ' + (terse ? key : key + '=\"' + key + '\"');\r\n    } else {\r\n      return '';\r\n    }\r\n  } else if (0 == key.indexOf('data') && 'string' != typeof val) {\r\n    return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\r\n  } else if (escaped) {\r\n    return ' ' + key + '=\"' + exports.escape(val) + '\"';\r\n  } else {\r\n    return ' ' + key + '=\"' + val + '\"';\r\n  }\r\n};\r\n\r\n/**\r\n * Render the given attributes object.\r\n *\r\n * @param {Object} obj\r\n * @param {Object} escaped\r\n * @return {String}\r\n */\r\nexports.attrs = function attrs(obj, terse){\r\n  var buf = [];\r\n\r\n  var keys = Object.keys(obj);\r\n\r\n  if (keys.length) {\r\n    for (var i = 0; i < keys.length; ++i) {\r\n      var key = keys[i]\r\n        , val = obj[key];\r\n\r\n      if ('class' == key) {\r\n        if (val = joinClasses(val)) {\r\n          buf.push(' ' + key + '=\"' + val + '\"');\r\n        }\r\n      } else {\r\n        buf.push(exports.attr(key, val, false, terse));\r\n      }\r\n    }\r\n  }\r\n\r\n  return buf.join('');\r\n};\r\n\r\n/**\r\n * Escape the given string of `html`.\r\n *\r\n * @param {String} html\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escape = function escape(html){\r\n  var result = String(html)\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\"/g, '&quot;');\r\n  if (result === '' + html) return html;\r\n  else return result;\r\n};\r\n\r\n/**\r\n * Re-throw the given `err` in context to the\r\n * the jade in `filename` at the given `lineno`.\r\n *\r\n * @param {Error} err\r\n * @param {String} filename\r\n * @param {String} lineno\r\n * @api private\r\n */\r\n\r\nexports.rethrow = function rethrow(err, filename, lineno, str){\r\n  if (!(err instanceof Error)) throw err;\r\n  if ((typeof window != 'undefined' || !filename) && !str) {\r\n    err.message += ' on line ' + lineno;\r\n    throw err;\r\n  }\r\n  try {\r\n    str = str || _dereq_('fs').readFileSync(filename, 'utf8')\r\n  } catch (ex) {\r\n    rethrow(err, null, lineno)\r\n  }\r\n  var context = 3\r\n    , lines = str.split('\\n')\r\n    , start = Math.max(lineno - context, 0)\r\n    , end = Math.min(lines.length, lineno + context);\r\n\r\n  // Error context\r\n  var context = lines.slice(start, end).map(function(line, i){\r\n    var curr = i + start + 1;\r\n    return (curr == lineno ? '  > ' : '    ')\r\n      + curr\r\n      + '| '\r\n      + line;\r\n  }).join('\\n');\r\n\r\n  // Alter exception message\r\n  err.path = filename;\r\n  err.message = (filename || 'Jade') + ':' + lineno\r\n    + '\\n' + context + '\\n\\n' + err.message;\r\n  throw err;\r\n};\r\n\n},{\"fs\":2}],2:[function(_dereq_,module,exports){\n\n},{}]},{},[1])\n(1)\n});",
    "entry": false,
    "include": true,
    "deps": {}
  },
  "components/next-train/next-train.js": {
    "id": "components/next-train/next-train.js",
    "type": "js",
    "mtime": 1419337124000,
    "src": "'use strict';\n\n// component functionality includes.\nvar station = require('../station/station');\n\n// template includes\nvar templateError = require('./error.jade');\nvar templateTrains = require('../station/station.jade');\n\nmodule.exports = {\n    'init': init,\n    'station': getStationData,\n    'nextTrain:gotStationData': render\n};\n\nfunction init($el, bus) {\n    var $select = $el.find('select');\n    var newStation = $select.data('currentlyListening');\n    exports.active = newStation;\n    station.init($el.find('.station-detail'), bus);\n}\n\nfunction render(data, $el, bus) {\n    var $select = $el.find('select');\n    $select.attr('data-currently-listening', data.code);\n    $select.val(data.code);\n    $el.find('.error').empty();\n    $el.find('.trains').replaceWith($(templateTrains({ station: data })));\n    bus.trigger('resize');\n}\n\nfunction getStationData(station, $el, bus) {\n    $.ajax({\n        url: '/central/' + station.slug + '?ajax=true' ,\n        headers: {\n            Accept: 'application/json'\n        },\n        complete: function(xhr, status) {\n            console.log('complete', status)\n            if(status === 'error') {\n                errorCallback(station.slug, $el, bus);\n            }\n        },\n        success: function(data) {\n            bus.trigger('nextTrain:gotStationData', data);\n        }\n    });\n}\n\nfunction errorCallback(stationCode, $el, bus) {\n    console.log('ERROR CALLBACK');\n    $el.find('.trains').empty();\n    $el.find('.error').html(templateError({stationCode: stationCode}));\n    bus.trigger('resize');\n    bus.trigger('loader:hide');\n}\n\n",
    "deps": {
      "../station/station": "components/station/station.js",
      "./error.jade": "components/next-train/error.jade",
      "../station/station.jade": "components/station/station.jade"
    }
  },
  "fetchers/next-train/url-codes.json": {
    "id": "fetchers/next-train/url-codes.json",
    "type": "js",
    "mtime": 1418819202000,
    "src": "module.exports = {\n  \"bank\": \"BNK\",\n  \"barkingside\": \"BDE\",\n  \"bethnal-green\": \"BNG\",\n  \"bond-street\": \"BDS\",\n  \"buckhurst-hill\": \"BHL\",\n  \"chancery-lane\": \"CYL\",\n  \"chigwell\": \"CHG\",\n  \"debden\": \"DEB\",\n  \"ealing-broadway\": \"EBY\",\n  \"east-acton\": \"EAC\",\n  \"epping\": \"EPP\",\n  \"fairlop\": \"FLP\",\n  \"gants-hill\": \"GHL\",\n  \"grange-hill\": \"GRH\",\n  \"greenford\": \"GFD\",\n  \"hainault\": \"HAI\",\n  \"hanger-lane\": \"HLN\",\n  \"holborn\": \"HOL\",\n  \"holland-park\": \"HPK\",\n  \"lancaster-gate\": \"LAN\",\n  \"leyton\": \"LEY\",\n  \"leytonstone\": \"LYS\",\n  \"liverpool-street\": \"LST\",\n  \"loughton\": \"LTN\",\n  \"marble-arch\": \"MAR\",\n  \"mile-end\": \"MLE\",\n  \"newbury-park\": \"NEP\",\n  \"north-acton\": \"NAC\",\n  \"northolt\": \"NHT\",\n  \"notting-hill-gate\": \"NHG\",\n  \"oxford-circus\": \"OXC\",\n  \"perivale\": \"PER\",\n  \"queensway\": \"QWY\",\n  \"redbridge\": \"RED\",\n  \"roding-valley\": \"ROD\",\n  \"ruislip-gardens\": \"RUG\",\n  \"shepherds-bush\": \"SBC\",\n  \"snaresbrook\": \"SNB\",\n  \"south-ruislip\": \"SRP\",\n  \"south-woodford\": \"SWF\",\n  \"st-pauls\": \"STP\",\n  \"stratford\": \"SFD\",\n  \"theydon-bois\": \"THB\",\n  \"tottenham-court-road\": \"TCR\",\n  \"wanstead\": \"WAN\",\n  \"west-acton\": \"WAC\",\n  \"west-ruislip\": \"WRP\",\n  \"white-city\": \"WCT\",\n  \"woodford\": \"WFD\"\n};",
    "deps": {}
  },
  "components/train-status/train-status.js": {
    "id": "components/train-status/train-status.js",
    "type": "js",
    "mtime": 1413375011000,
    "src": "'use strict';\n\nvar template = require('./train-status.jade');\n\nexports.render = function (data) {\n    console.log('train status')\n  $('#tflStatus').replaceWith(template({ 'tflStatus': data }));\n};\n",
    "deps": {
      "./train-status.jade": "components/train-status/train-status.jade"
    }
  },
  "components/train-status/train-status.jade": {
    "id": "components/train-status/train-status.jade",
    "type": "js",
    "mtime": 1414422250000,
    "src": "var jade = require('jade-runtime');\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n;var locals_for_with = (locals || {});(function (tflStatus, count, RegExp) {\nif ( tflStatus)\n{\nbuf.push(\"<div id=\\\"tflStatus\\\"><ul>\");\ncount = 0;\n// iterate tflStatus\n;(function(){\n  var $$obj = tflStatus;\n  if ('number' == typeof $$obj.length) {\n\n    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n      var status = $$obj[$index];\n\nif ( status.StatusDetails!=='')\n{\nvar regex = new RegExp(' ', \"g\")\nbuf.push(\"<li\" + (jade.cls(['line '+status.Line.Name.replace(regex, '')], [true])) + \"><h3>\" + (jade.escape(null == (jade_interp = status.Line.Name) ? \"\" : jade_interp)) + \"</h3><div>\" + (jade.escape(null == (jade_interp = status.StatusDetails) ? \"\" : jade_interp)) + \"</div>\");\ncount++\nbuf.push(\"</li>\");\n}\n    }\n\n  } else {\n    var $$l = 0;\n    for (var $index in $$obj) {\n      $$l++;      var status = $$obj[$index];\n\nif ( status.StatusDetails!=='')\n{\nvar regex = new RegExp(' ', \"g\")\nbuf.push(\"<li\" + (jade.cls(['line '+status.Line.Name.replace(regex, '')], [true])) + \"><h3>\" + (jade.escape(null == (jade_interp = status.Line.Name) ? \"\" : jade_interp)) + \"</h3><div>\" + (jade.escape(null == (jade_interp = status.StatusDetails) ? \"\" : jade_interp)) + \"</div>\");\ncount++\nbuf.push(\"</li>\");\n}\n    }\n\n  }\n}).call(this);\n\nif ( count === 0)\n{\nbuf.push(\"<div>All lines operational.</div>\");\n}\nbuf.push(\"</ul></div>\");\n}}.call(this,\"tflStatus\" in locals_for_with?locals_for_with.tflStatus:typeof tflStatus!==\"undefined\"?tflStatus:undefined,\"count\" in locals_for_with?locals_for_with.count:typeof count!==\"undefined\"?count:undefined,\"RegExp\" in locals_for_with?locals_for_with.RegExp:typeof RegExp!==\"undefined\"?RegExp:undefined));;return buf.join(\"\");\n};",
    "deps": {
      "jade-runtime": "jade-runtime"
    }
  },
  "components/station/station.js": {
    "id": "components/station/station.js",
    "type": "js",
    "mtime": 1419275845000,
    "src": "'use strict';\n\nvar platform = require('../platform/platform');\n\nexports.init = function($el, bus) {\n    // for each platform on the station.\n    platform.init($el.find('.platform'), bus);\n    bus.on('new platform', newPlatform);\n    bus.on('remove platform', removePlatform);\n};\n\n\nfunction newPlatform() {\n    console.log('add new platform');\n}\n\nfunction removePlatform() {\n    console.log('remove platform');\n}",
    "deps": {
      "../platform/platform": "components/platform/platform.js"
    }
  },
  "components/next-train/error.jade": {
    "id": "components/next-train/error.jade",
    "type": "js",
    "mtime": 1419336608000,
    "src": "var jade = require('jade-runtime');\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n;var locals_for_with = (locals || {});(function (stationCode) {\nbuf.push(\"<div class=\\\"error trains\\\"><h2>Ooops</h2><div class=\\\"detail\\\">Something Went wrong. you can try refreshing the page, or maybe pop back later.<p>\" + (jade.escape(null == (jade_interp = 'An error occured fetching ' + stationCode) ? \"\" : jade_interp)) + \"</p></div><hr/></div>\");}.call(this,\"stationCode\" in locals_for_with?locals_for_with.stationCode:typeof stationCode!==\"undefined\"?stationCode:undefined));;return buf.join(\"\");\n};",
    "deps": {
      "jade-runtime": "jade-runtime"
    }
  },
  "components/platform/platform.js": {
    "id": "components/platform/platform.js",
    "type": "js",
    "mtime": 1419276053000,
    "src": "'use strict';\n\n// train left\n// new train added\n// complete refresh\n\nvar train = require('../train/train');\n\n\nexports.init = function($el, bus) {\n    train.init($el.find('.train'));\n    bus.on('WFD.trains.Westbound', newTrain.bind(null, $el));\n    bus.on('WFD.trains.Eastbound', newTrain.bind(null, $el));\n    // bus.on('remove train', removeTrain);\n};\n\nfunction newTrain($el) \n{\n    debugger;\n    $el.append($('<h1>hhiii</h1>'))\n}\n\nfunction removeTrain() {\n    alert('remove train');\n}",
    "deps": {
      "../train/train": "components/train/train.js"
    }
  },
  "components/train/train.js": {
    "id": "components/train/train.js",
    "type": "js",
    "mtime": 1419253905000,
    "src": "// property updated\n\nexports.init = function($el, bus) {\n    console.log('init train');\n\n};",
    "deps": {}
  },
  "components/station/station.jade": {
    "id": "components/station/station.jade",
    "type": "js",
    "mtime": 1419188338000,
    "src": "var jade = require('jade-runtime');\n\nmodule.exports = function template(locals) {\nvar buf = [];\nvar jade_mixins = {};\nvar jade_interp;\n;var locals_for_with = (locals || {});(function (station) {\nbuf.push(\"<div class=\\\"trains station-detail\\\">\");\nvar noTrains = true;\nif ( station)\n{\n// iterate station.trains\n;(function(){\n  var $$obj = station.trains;\n  if ('number' == typeof $$obj.length) {\n\n    for (var direction = 0, $$l = $$obj.length; direction < $$l; direction++) {\n      var trains = $$obj[direction];\n\nif ( trains.length > 0)\n{\nbuf.push(\"<div class=\\\"platform direction\\\"><h3>\" + (jade.escape(null == (jade_interp = direction) ? \"\" : jade_interp)) + \"</h3><ul class=\\\"trains\\\">\");\n// iterate trains\n;(function(){\n  var $$obj = trains;\n  if ('number' == typeof $$obj.length) {\n\n    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n      var train = $$obj[$index];\n\nbuf.push(\"<li><li class=\\\"train\\\"><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = train.dueIn) ? \"\" : jade_interp)) + \"</span></div><!--a(href='/central-line/' + train.destination.replace(/ /g, '-').toLowerCase())--><span class=\\\"destination\\\">\" + (jade.escape(null == (jade_interp = train.destination) ? \"\" : jade_interp)) + \"</span><br/><span class=\\\"detail\\\">\" + (jade.escape(null == (jade_interp = train.location) ? \"\" : jade_interp)) + \"</span></li></li>\");\n    }\n\n  } else {\n    var $$l = 0;\n    for (var $index in $$obj) {\n      $$l++;      var train = $$obj[$index];\n\nbuf.push(\"<li><li class=\\\"train\\\"><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = train.dueIn) ? \"\" : jade_interp)) + \"</span></div><!--a(href='/central-line/' + train.destination.replace(/ /g, '-').toLowerCase())--><span class=\\\"destination\\\">\" + (jade.escape(null == (jade_interp = train.destination) ? \"\" : jade_interp)) + \"</span><br/><span class=\\\"detail\\\">\" + (jade.escape(null == (jade_interp = train.location) ? \"\" : jade_interp)) + \"</span></li></li>\");\n    }\n\n  }\n}).call(this);\n\nbuf.push(\"</ul></div>\");\nnoTrains = false;\n}\n    }\n\n  } else {\n    var $$l = 0;\n    for (var direction in $$obj) {\n      $$l++;      var trains = $$obj[direction];\n\nif ( trains.length > 0)\n{\nbuf.push(\"<div class=\\\"platform direction\\\"><h3>\" + (jade.escape(null == (jade_interp = direction) ? \"\" : jade_interp)) + \"</h3><ul class=\\\"trains\\\">\");\n// iterate trains\n;(function(){\n  var $$obj = trains;\n  if ('number' == typeof $$obj.length) {\n\n    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {\n      var train = $$obj[$index];\n\nbuf.push(\"<li><li class=\\\"train\\\"><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = train.dueIn) ? \"\" : jade_interp)) + \"</span></div><!--a(href='/central-line/' + train.destination.replace(/ /g, '-').toLowerCase())--><span class=\\\"destination\\\">\" + (jade.escape(null == (jade_interp = train.destination) ? \"\" : jade_interp)) + \"</span><br/><span class=\\\"detail\\\">\" + (jade.escape(null == (jade_interp = train.location) ? \"\" : jade_interp)) + \"</span></li></li>\");\n    }\n\n  } else {\n    var $$l = 0;\n    for (var $index in $$obj) {\n      $$l++;      var train = $$obj[$index];\n\nbuf.push(\"<li><li class=\\\"train\\\"><div class=\\\"due-container\\\"><span class=\\\"due\\\">\" + (jade.escape(null == (jade_interp = train.dueIn) ? \"\" : jade_interp)) + \"</span></div><!--a(href='/central-line/' + train.destination.replace(/ /g, '-').toLowerCase())--><span class=\\\"destination\\\">\" + (jade.escape(null == (jade_interp = train.destination) ? \"\" : jade_interp)) + \"</span><br/><span class=\\\"detail\\\">\" + (jade.escape(null == (jade_interp = train.location) ? \"\" : jade_interp)) + \"</span></li></li>\");\n    }\n\n  }\n}).call(this);\n\nbuf.push(\"</ul></div>\");\nnoTrains = false;\n}\n    }\n\n  }\n}).call(this);\n\n}\nif ( noTrains)\n{\nbuf.push(\"<h3 class=\\\"noTrains\\\">No Trains</h3>\");\n}\nbuf.push(\"</div>\");}.call(this,\"station\" in locals_for_with?locals_for_with.station:typeof station!==\"undefined\"?station:undefined));;return buf.join(\"\");\n};",
    "deps": {
      "jade-runtime": "jade-runtime"
    }
  },
  "components/floater/floater.js": {
    "id": "components/floater/floater.js",
    "type": "js",
    "mtime": 1419255756000,
    "src": "'use strict';\n\nfunction hideLoader($el) {\n    console.log('hide loader');\n    $el.removeClass('loading');\n}\n\nfunction showLoader($el) {\n    console.log('show loader');\n    $el.addClass('loading');\n}\n\nfunction resize($el) {\n    $el.height($el.find('.container').height());\n    //$('#floater').width($('.container').width());\n}\n\nmodule.exports = {\n    'loader:show': showLoader,\n    'loader:hide': hideLoader,\n    'resize': resize\n};\n",
    "deps": {}
  },
  "components/station-switcher/station-switcher.js": {
    "id": "components/station-switcher/station-switcher.js",
    "type": "js",
    "mtime": 1419337343000,
    "src": "'use strict';\n\nfunction init($el, bus) {\n    $el.change(function(e) {\n        var newStationSlug = e.currentTarget.selectedOptions[0].label.replace(/ /g, '-').toLowerCase();\n        bus.trigger('page:load', '/central/' + newStationSlug);\n    });\n}\n\n\nmodule.exports = {\n    init: init\n};\n",
    "deps": {}
  },
  "node_modules/backbone-events-standalone/index.js": {
    "id": "node_modules/backbone-events-standalone/index.js",
    "type": "js",
    "mtime": 1378401613000,
    "src": "module.exports = require('./backbone-events-standalone');\n",
    "deps": {
      "./backbone-events-standalone": "node_modules/backbone-events-standalone/backbone-events-standalone.js"
    }
  },
  "node_modules/backbone-events-standalone/backbone-events-standalone.js": {
    "id": "node_modules/backbone-events-standalone/backbone-events-standalone.js",
    "type": "js",
    "mtime": 1409751378000,
    "src": "/**\n * Standalone extraction of Backbone.Events, no external dependency required.\n * Degrades nicely when Backone/underscore are already available in the current\n * global context.\n *\n * Note that docs suggest to use underscore's `_.extend()` method to add Events\n * support to some given object. A `mixin()` method has been added to the Events\n * prototype to avoid using underscore for that sole purpose:\n *\n *     var myEventEmitter = BackboneEvents.mixin({});\n *\n * Or for a function constructor:\n *\n *     function MyConstructor(){}\n *     MyConstructor.prototype.foo = function(){}\n *     BackboneEvents.mixin(MyConstructor.prototype);\n *\n * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n * (c) 2013 Nicolas Perriault\n */\n/* global exports:true, define, module */\n(function() {\n  var root = this,\n      breaker = {},\n      nativeForEach = Array.prototype.forEach,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      slice = Array.prototype.slice,\n      idCounter = 0;\n\n  // Returns a partial implementation matching the minimal API subset required\n  // by Backbone.Events\n  function miniscore() {\n    return {\n      keys: Object.keys || function (obj) {\n        if (typeof obj !== \"object\" && typeof obj !== \"function\" || obj === null) {\n          throw new TypeError(\"keys() called on a non-object\");\n        }\n        var key, keys = [];\n        for (key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            keys[keys.length] = key;\n          }\n        }\n        return keys;\n      },\n\n      uniqueId: function(prefix) {\n        var id = ++idCounter + '';\n        return prefix ? prefix + id : id;\n      },\n\n      has: function(obj, key) {\n        return hasOwnProperty.call(obj, key);\n      },\n\n      each: function(obj, iterator, context) {\n        if (obj == null) return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n          obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n          for (var i = 0, l = obj.length; i < l; i++) {\n            if (iterator.call(context, obj[i], i, obj) === breaker) return;\n          }\n        } else {\n          for (var key in obj) {\n            if (this.has(obj, key)) {\n              if (iterator.call(context, obj[key], key, obj) === breaker) return;\n            }\n          }\n        }\n      },\n\n      once: function(func) {\n        var ran = false, memo;\n        return function() {\n          if (ran) return memo;\n          ran = true;\n          memo = func.apply(this, arguments);\n          func = null;\n          return memo;\n        };\n      }\n    };\n  }\n\n  var _ = miniscore(), Events;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  Events = {\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = {};\n        return this;\n      }\n\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                  (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeners = this._listeners;\n      if (!listeners) return this;\n      var deleteListener = !name && !callback;\n      if (typeof name === 'object') callback = this;\n      if (obj) (listeners = {})[obj._listenerId] = obj;\n      for (var id in listeners) {\n        listeners[id].off(name, callback, this);\n        if (deleteListener) delete this._listeners[id];\n      }\n      return this;\n    }\n\n  };\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n    }\n  };\n\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  _.each(listenMethods, function(implementation, method) {\n    Events[method] = function(obj, name, callback) {\n      var listeners = this._listeners || (this._listeners = {});\n      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));\n      listeners[id] = obj;\n      if (typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  });\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Mixin utility\n  Events.mixin = function(proto) {\n    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',\n                   'listenToOnce', 'bind', 'unbind'];\n    _.each(exports, function(name) {\n      proto[name] = this[name];\n    }, this);\n    return proto;\n  };\n\n  // Export Events as BackboneEvents depending on current context\n  if (typeof define === \"function\") {\n    define(function() {\n      return Events;\n    });\n  } else if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = Events;\n    }\n    exports.BackboneEvents = Events;\n  } else {\n    root.BackboneEvents = Events;\n  }\n})(this);\n",
    "deps": {}
  },
  "pages/station/station.js": {
    "id": "pages/station/station.js",
    "type": "js",
    "mtime": 1419337339000,
    "src": "'use strict';\n\n\n// internal browser events bus.\nvar bus = window.bus = require(\"../../node_modules/backbone-events-standalone\").mixin({});\n\n// router\nvar page = require('../../public/libs/page.js');\nvar urlCodes = require('../../fetchers/next-train/url-codes.json');\n\nvar $mapContainer = $('#map-container');\nvar $floater = $('#floater');\n[\n    {\n        $el: $mapContainer,\n        events: require('../../components/tubes/tubes.js')\n    },\n    {\n        $el: $floater,\n        events: require('../../components/floater/floater.js')\n    },\n    {\n        $el: $floater.find('#nextTrain'),\n        events: require('../../components/next-train/next-train.js')\n    },\n    {\n        $el: $floater.find('select'),\n        events: require('../../components/station-switcher/station-switcher.js')\n    }\n].forEach(function(component) {\n    component.events.init && component.events.init(component.$el, bus);\n    for (var ev in component.events) {\n        bus.on(ev, function(ev, events) {\n            // strip args added for bind and create array.\n            var mainArguments = Array.prototype.slice.call(arguments, 2);\n            // add $el and bus.\n            mainArguments.push(component.$el, bus);\n            // apply with modified arguments.\n            events[ev].apply(null, mainArguments);\n        }.bind(null, ev, component.events));\n    }\n});\n\n\nfunction listen(station, socket) {\n    console.log('listen called', station.code);\n    socket.emit('station:listen:start', station.code);\n    socket.on('station:' + station.code + ':change', function(changes) {\n        changes.forEach(function(change) {\n\n            if(change.parent) {\n                console.log('trigger', change.parent);\n                bus.trigger(change.parent, change);\n            }\n        });\n        // changes.forEach(function(change) {\n        //     if (change.change === 'value changed' ) {\n        //         bus.emit();\n        //     }\n        // });\n    });\n};\n\nvar stopListening = function(oldStation, socket) {\n    console.log('stop listen called', oldStation.code);\n    socket.emit('station:listen:stop', oldStation.code);\n    socket.off('station:' + oldStation.code);\n};\n\n\nbus.on('page:load', function(path) {\n    page(path);\n});\n\nbus.on('station', function(station) {\n    stopListening(station, socket);\n});\nbus.on('nextTrain:gotStationData', function(station) {\n    listen(station, socket);\n});\n\n\nvar url;\nif(window.location.hostname === 'woodford.today') {\n    url = 'http://woodford.today:80/';\n} else {\n    url = 'http://localhost/';\n}\n\n\nvar socket = io(url);\n\npage();\n\nconsole.log('000');\n\npage('/central/:stationName', function(context) {\n    bus.trigger('station', {\n        slug: context.params.stationName,\n        code: urlCodes[context.params.stationName]\n    });\n});\n\n// window.onresize = function() {};\n",
    "deps": {
      "../../node_modules/backbone-events-standalone": "node_modules/backbone-events-standalone/index.js",
      "../../public/libs/page.js": "public/libs/page.js",
      "../../fetchers/next-train/url-codes.json": "fetchers/next-train/url-codes.json",
      "../../components/tubes/tubes.js": "components/tubes/tubes.js",
      "../../components/floater/floater.js": "components/floater/floater.js",
      "../../components/next-train/next-train.js": "components/next-train/next-train.js",
      "../../components/station-switcher/station-switcher.js": "components/station-switcher/station-switcher.js"
    },
    "entry": true
  },
  "components/tubes/tubes.js": {
    "id": "components/tubes/tubes.js",
    "type": "js",
    "mtime": 1419259096000,
    "src": "module.exports = {\n    'station' : focus\n};\n\nfunction focus(station, $el) {\n    $el.attr('data-station', station.code);\n    $el.find('li.active').removeClass('active');\n    $('html, body').animate({scrollTop : 0}, 500);\n    $('li.' + station.code ).addClass('active');\n    setTimeout(function() {\n        $('ul.line li  a.point').removeClass('point');\n        $('ul.line li.' + station.code + ' a').addClass('point');\n    }, 1250);\n};",
    "deps": {}
  }
}